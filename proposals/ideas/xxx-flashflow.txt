Filename: xxx-flashflow.txt
Title: FlashFlow: A Secure Speed Test for Tor (Parent Proposal)
Author: Matthew Traudt, Rob Jansen, Aaron Johnson
Created: __________
Status: Draft

Overview:

X. Introduction

FlashFlow is a new distributed bandwidth measurement system for Tor that
consists of a single authority node instructing one or more measurement nodes
when and how to measure Tor relays. A measurement consists of the following
steps:

  X. The measurement nodes demonstrate to the target relay permission to
     perform measurements.
  X. The measurement nodes open many TCP connections to the target relay and
     create a one-hop circuit to the target relay on each one.
  X. For 30 seconds the measurement nodes send measurement cells to the
     target relay and verify that the cells echoed back match the ones sent.
     During this time the relay caps the amount of background traffic it
     transfers. Background and measurement traffic are handled separately at
     the relay.
  X. For every second during the measurement, the measurement nodes report to
     the authority node how much traffic was echoed back.
     The target relay also reports the amount of per-second background
     (non-measurement) traffic.
  X. The authority node sums the per-second reported throughputs into 30 sums
     (one for each second) and calculates the median. This is estimated
     capacity of the relay.

FlashFlow performs a measurement of every relay according to a schedule
described later in this document. Periodically it produces relay capacity
estimates in the form of a v3bw file, which is suitable for consumption by a Tor
directory and allows FlashFlow to be a voting "bandwidth authority."

FlashFlow is more performant than Torflow: FlashFlow takes 5 hours to measure
the entire existing Tor network from scratch while Torflow takes 2 days;
FlashFlow measures relays it hasn't seen recently as soon as it learns about
them (i.e. every new consensus) while Torflow can take a day or more; and
FlashFlow accurately measures new high-capacity relays the first time and
every time while Torflow takes days/weeks to assign them their full fair share
of bandwidth (especially for non-exits). FlashFlow is more secure than
Torflow: FlashFlow allows a relay to inflate its measured capacity by up to
1.33x (configured by a parameter) while Torflow allows weight inflation by a
factor of 89x [0] or even 177x [1].

[XXX A paragraph summarizing the layout of this proposal]

X. Deployment Stages

FlashFlow's deployment shall be broken up into three stages.

In the short term we want to implement a working FlashFlow measurement system.
This requires code changes in little-t tor and an external FlashFlow codebase.
The majority of the implementation work will be done here, and the product is
a complete FlashFlow measurement system. Remaining pieces (e.g.
authentication) are added later for enhanced security and network performance.

In the medium term we want to begin collecting data with a FlashFlow
deployment. The intermediate results and v3bw files produced will be made
available (semi?) publicly for study.

In the long term experiments will be performed to study ways of using FF v3bw
files to improve load balancing. Two examples: (1) using FF v3bw files instead
of sbws's (and eventually phasing out torflow/sbws), and (2) continuing to run
sbws but use FF's results as a better estimate of relay capacity than observed
bandwidth. Authentication and other FlashFlow features necessary to make it
completely ready for full production deployment will be worked on here.

X. FlashFlow measurement system: Short term

The core measurement mechanics will be implemented in little-t tor, but a
separate codebase for the FlashFlow side of the measurement system will also
be created. This section is divided into three parts: first a discussion of
changes/additions that logically reside entirely within tor (essentially:
relay-side modifications), second a discussion of the separate FlashFlow
code that also requires some amount of tor changes (essentially: measurer-side
modifications), and third a security discussion.

X.X Little-T Tor Components

The primary additions/changes that entirely reside within tor on the relay
side:

  - New torrc options/consensus parameters.
  - New cell types.
  - Pre-measurement handshaking (with authentication reduced to stub methods
    that always indicate successful verification).
  - Measurement mode, during which the relay will echo traffic with measurers,
    set a cap on the amount of background traffic it transfers, and report the
    amount of transferred background traffic.

X.X.X Parameters

FlashFlow will require some consensus parameters/torrc options. Each has some
default value if nothing is specified; the consensus parameter overrides this
default value; the torrc option overrides both.

FFMeasurementsAllowed: In lieu of a proper chain of authentication that gives
FF measurers permission to perform measurements, this allows/disallows this
relay to be measured by anyone. Possible values: 0, 1. Default: 0 (disallowed).

FFSecondsBetweenMeasurements: the amount of time, in seconds, that must pass
after a FF deployment's measurement of a relay before that relay should allow
another measurement by the same FF deployment. It doesn't matter if the
measurement was successful. If there are multiple deployments, relays track
the time since the last measurement by each deployment separately. Possible
values in the range [0 seconds, 7 days] inclusive. Default: 1 day.

FFBackgroundTrafficPercent: the maximum amount of regular non-measurement
traffic a relay should handle while being measured, as a percent of total
traffic (measurement + non-measurement).  This parameter is a trade off
between having to limit background traffic and limiting how much a relay can
inflate its result by handling no background traffic but reporting that it has
done so.  Possible values are in the range [0, 99] inclusive. Default: 25 (a
maximum inflation factor of 1.33).

FFMaxMeasurementDuration: the maximum amount of time, in seconds, that is
allowed to pass from the moment the relay is notified that a measurement will
begin soon and the end of the measurement. If this amount of time passes, the
relay shall close all measurement connections and exit its measurement mode.
Note this duration includes handshake time, thus it necessarily is larger than
the expected actual measurement duration.  Possible values are in the range
[10, 120] inclusive. Default: 45.


X.X.X New Cell Types

FlashFlow will introduce a new cell command MEASURE.

The payload of each MEASURE cell consists of:

  Measure command [1 byte]
  Length          [2 bytes]
  Data            [Length-3 bytes]

The measure commands are:

  0 -- MSM_PARAMS    [forward]
  1 -- MSM_PARAMS_OK [backward]
  2 -- MSM_ECHO      [forward and backward]
  3 -- MSM_BG        [backward]
  4 -- MSM_ERR       [forward and backward]

Forward cells are sent from the Tor measurement client to the relay. Backward
cells are sent from the relay to the Tor measurement client.

PARAMS and PARAMS_OK are used during the pre-measurement stage to tell the
target what to expect and for the relay to positively acknowledge the message.
ECHO cells are the measurement traffic; the measurer generates them, sends
them to the target, and the target echos them back. The target send a BG cells
once per second to report the amount of background traffic it is handling. ERR
cells are used to signal to the other party that there has been some sort of
problem and that the measurement should be aborted. These cell types are
described in more detail in the next section.

The only cell type that is sometimes encrypted is MSM_ECHO; all other types
are never encrypted.

The relay "decrypts" ECHO cells before sending them back to the measurer; this
mirrors the way relays decrypt/encrypt RELAY_DATA cells in order to induce
realistic cryptographic CPU load. The measurer usually skips encrypting ECHO
cells to reduce its own CPU load; however, to verify the relay is actually
correctly decrypting all cells, the measurer will choose random outgoing
cells, encrypt them, remember the ciphertext, and verify the corresponding
incoming cell matches.

X.X.X Pre-Measurement Handshaking/Starting a Measurement

Measurers start connecting to the target relay and each sends it a MSM_PARAMS
cell. If the target is unwilling to be measured at this time, it responds with
an error cell and closes the connection.  Otherwise it checks that the
parameters of the measurement are acceptable (e.g. the length isn't too long,
the indicated relay identity is its own, etc.). Initially, this will always be
true. If the target is happy, it sends a MSM_PARAMS_OK, otherwise it sends a
MSM_ERR and closes the connection.


Upon receiving a MSM_PARAMS_OK from the target, the measurer will open the
remaining sockets with the target. If it receives a MSM_ERR, it reports the
error to the coordinator and considers the measurement a failure.  The target
needs to treat connections from measurers as special and not count them in the
DoS detection algorithm.

The payload of MSM_PARAMS cells [XXX more may need to be added]:

  - num_conns    [2 bytes]
  - msm_duration [1 byte]
  - bg_conn      [1 byte]

num_conns is the total number of TCP connections this measurer will open with the
target for this measurement. msm_duration is the duration, in seconds, that
the actual measurement will last.  bg_conn is a flag indicating whether or not
this connection is to be used for background traffic reports (MSM_BG cells)
instead of MSM_ECHO traffic.

[XXX Do MSM_BG cells really need their own connection? If we do that, should
it be considered a "control connection"? What else would the control
connection be used for?
https://github.com/pastly/torspec/pull/1#discussion_r397472928]

MSM_PARAMS_OK has no payload: it's just padding bytes to make the cell 514
bytes long.

The payload of MSM_ECHO cells:

  - arbitrary bytes [max to fill up 514 byte cell]

[XXX it's possible while implementing the verification of MSM_ECHO cells that
it will be discovered that it will be impossible to allow the measurer to skip
encryption of most cells while requiring the relay to decrypt all cells]

The payload of MSM_BG cells:

  - second        [1 byte]
  - sent_bg_bytes [4 bytes]
  - recv_bg_bytes [4 bytes]

second is the number of seconds since the measurement began. MSM_BG cells are
sent once per second. The first cell will have this set to 1, and each
subsequent cell will increment it by one. sent_bg_bytes is the number of
background traffic bytes sent in the last second (since the last MSM_BG cell).
recv_bg_bytes is the same but for received bytes.

The payload of MSM_ERR cells:

  - err_code [1 byte]
  - err_str  [possibly zero-len null-terminated string]

The error code is one of:

  [... XXX TODO ...]
  255 -- OTHER

The error string is optional in all cases. It isn't present if the first byte
of err_str is null, otherwise it is present. It ends at the first null byte or
the end of the cell, whichever comes first.

X.X.X Measurement Mode

The relay considers the measurement to have started the moment it receives the
first MSM_ECHO cell from any measurer. At this point, the relay

  - starts a repeating 1s timer on which it will report the amount of
    background traffic on the appropriate connection.
  - enters "measurement mode" and limits the amount of background traffic it
    handles according to the torrc option/consensus parameter.

The relay decrypts and echos back all MSM_ECHO cells it receives on
measurement connections until it has reported its amount of background traffic
the same number of times as there are seconds in the measurement (e.g. 30
per-second reports for a 30 second measurement). After sending the last
MSM_BG cell, the relay drops all buffered MSM_ECHO cells, closes all
measurement connections, and exits measurement mode. It will not allow itself
to be measured again for a period of time governed by the torrc
option/consensus parameter.

During the measurement the relay targets a ratio of background traffic to
measurement traffic as specified by a consensus parameter/torrc option.
Strategies for how to best achieve this with the smallest impact on background
client traffic possible, even in the presence of a lot/very little measurement
traffic, will be investigated.  The FF prototype worked in the following way:
Assume the ratio is 25% and the relay has handled 7500 cells of measurement
traffic recently. Tor then limits itself to 2500 cells of non-measurement
traffic this scheduling round. In case there was very little measurement
traffic since the last background traffic scheduling round, tor would allow
itself to send at least 100 cells of background traffic.

X.X FlashFlow Components

The FF coordinator and measurer code will reside in a FlashFlow repository
separate from little-t tor. The FF measurer code will require supporting tor
code, which is discussed in this section.

The coordinator is responsible for scheduling measurements, aggregating
results, and producing v3bw files.
It needs continuous access to new consensus files, which it can obtain by
running an accompanying Tor process in client mode.

The measurers take commands from the coordinator, connect to target relays
with many sockets, send them traffic, and verify the received traffic is the
same as what was sent.
Measurers need access to a lot of internal tor functionality. One strategy is
to house as much logic as possible inside an compile-time-optional control
port module that calls into other parts of tor. Alternatively FlashFlow could
link against tor and call internal tor functions directly.

[XXX for now I'll assume that an optional little-t tor control port module
housing a lot of this code is the best idea.]

Notable new things that internal tor code will need to do on the measurer
(client) side:

  X. Open many TLS+TCP connections to the same relay on purpose
  X. Verify echo cells

X.X.X Open many connections

FlashFlow prototypes needed to "hack in" a flag in the
open-a-connection-with-this-relay function call change that indicated whether
or not we wanted to force a new connection to be created. Most of Tor doesn't
care if it reuses an existing connection, but FF does want to create many
different connections. The cleanest way to accomplish this will be
investigated.

On the relay side, these measurer connections need to not count towards DoS
detection algorithms.

X.X.X Verify echo cells

A parameter will exist to tell the measurers with what frequency they shall
verify cells echoed back to them match what they sent. This parameter does not
need to exist outside of the FF deployment (e.g. it doesn't need to be a
consensus parameter).

The parameter instructs the measurers to check 1 out of every N cells.

The measurer keeps a count of how many measurement cells it has sent. It also
logically splits its output stream of cells into buckets of size N. At the
start of each bucket (when num_sent % N == 0), the measurer chooses a random
index in the bucket. Upon sending the cell at that index (num_sent % N ==
chosen_index), the measurer records the cell.

The measurer also counts cells that it receives. When it receives a cell at an
index that was recorded, it verifies that the received cell matches the
recorded sent cell. If they match, no special action is taken. If they don't
match, the measurer indicates failure to the coordinator and target relay and
closes all connections, ending the measurement.

X.X.X.X Example

Consider bucket_size is 1000. For the moment ignore cell encryption.

We start at idx=0 and pick an idx in [0, 1000) to record, say 640. At idx=640
we record the cell. At idx=1000 we choose a new idx in [1000, 2000) to record,
say 1236. At idx=1236 we record the cell. At idx=2000 we choose a new idx in
[2000, 3000). Etc.

There's 2000+ cells in flight and the measurer has recorded two items:

  - (640, contents_of_cellA)
  - (1236, contents_of_cellB)

Consider the receive side now. It counts the cells it receives. At receive
idx=640, it checks the received cell matches the saved cell from before. At
receive idx=1236, it again checks the received cell matches. Etc.

X.X.X.X Motivation

A malicious relay may want to skip decryption of measurement cells to save CPU
cycles and obtain a higher capacity estimate. More generally, it could
generate fake measurement cells locally, ignore the measurement traffic it is
receiving, and flood the measurer with more traffic that it (the measurer) is
even sending.

The security of echo cell verification is discussed in Security Section [XXX].

X.X Security

In this section we discuss the security of various aspects of FlashFlow and
the tor changes it requires.

X.X.X Echo Cell Verification: Bucket Size

A smaller bucket size means more cells are checked and FF is more likely to
detect a malicious target. It also means more bookkeeping overhead (CPU/RAM).

An adversary that knows `bucket_size` and cheats on one item out of every
`bucket_size` items will have a `1 / bucket_size` chance of getting caught in
the first bucket.  This is the worst case adversary. While cheating on just a
single item per bucket yields very little advantage, cheating on more items
per bucket increases the likelihood the adversary gets caught. Thus only the
worst case is considered here.

In general, the odds the adversary can successfully cheat in a single bucket
are

    (bucket_size-1)/bucket_size

Thus the odds the adversary can cheat in `X` consecutive buckets are

    [(bucket_size-1)/bucket_size]^X

In our case, X will be highly varied: Slow relays won't see very many
buckets, but fast relays will. The damage to the network a very slow relay can
do by faking being only slightly faster is limited. Nonetheless, for now we
motivate the selection of bucket size, with a slow relay:

  - Assume a very slow relay of 1 Mbit/s capacity that will cheat 1 cell in
    each bucket. Assume a 30 second measurement.
  - The relay will handle `1 * 30` = 30 Mbit of traffic during the
    measurement, or 3.75 MB, or 3.75 million bytes.
  - Cells are 514 bytes. Approximately (e.g. ignoring TLS) 7300 cells will be
    sent/recv over the course of the measurement.
  - A `bucket_size` of 50 results in about 146 buckets over the course of the
    30s measurement.
  - Therefore, the odds of the adversary cheating successfully as
    `(49/50)^(146)`, or about 5.2%.

This sounds high, but a relay capable of double the bandwidth (2 Mbit/s) will
have (49/50)^(2*146) or 0.2% odds of success. Quite low already.

Wanting a <1% chance that a 10 Mbit/s relay can successfully cheat results in
a bucket size of approximately 125:

  - 10 * 30 = 300 Mbit of traffic during 30s measurement. 37.5 million bytes.
  - 37,500,000 bytes / 514 bytes/cell = ~73,000 cells
  - bucket size of 125 cells means 73,000 / 125 = 584 buckets
  - (124/125)^(584) = 0.918% chance of successfully cheating

Slower relays can cheat more easily but the amount of extra weight they can
obtain is insignificant in absolute terms. Faster relays are essentially
unable to cheat.

X.X.X Weight Inflation

Target relays are an active part of the measurement process; they know they
are getting measured. While a relay cannot fake the measurement traffic, it
can trivially stop transferring client background traffic for the duration of
the measurement yet claim it carried some. More generally, there is no
verification on the claimed amount of background traffic during the
measurement, the relay can claim whatever it wants, but it will not be trusted
above the ratio the FlashFlow deployment is configured to know. This places an
easy to understand, firm, and (if set as we suggest) low cap on how much a
relay can inflate its measured capacity.

Consider a background/measurement ratio of 1/4, or 25%. Assume the relay in
question has a hard limit on capacity (e.g. from its NIC) of 100 Mbit/s. The
relay is supposed to use up to 25% of its capacity for background traffic and
the remaining 75%+ capacity for measurement traffic. Instead the relay ceases
carrying background traffic, uses all 100 Mbit/s of capacity to handle
measurement traffic, and reports ~33 Mbit/s of background traffic (33/133 =
~25%). FlashFlow would trust this and consider the relay capable of 133
Mbit/s. (If the relay were to report more than ~33 Mbit/s, FlashFlow caps them
down to just ~33 Mbit/s.) With r=25%, FlashFlow only allows 1.33x weight
inflation.

Prior work shows that Torflow allows weight inflation by a factor of 89x [0]
or even 177x [1].

The ratio chosen is a trade off between impact on background traffic and
security: r=50% allows a relay to double its weight but won't impact client
traffic for relays with steady state throughput below 50%, while r=10% allows
a very low inflation factor but will cause throttling of client traffic at far
more relays.

We feel r=25% (thus 1.33x inflation) is reasonable for initial deployment.
Longer term, other ratios can be explored.

It may be possible to catch relays performing this attack, especially if they
literally drop all background traffic during the measurement: have the
measurer (or some party on its behalf) create a regular stream through the
relay and measure the throughput on the stream before/during/after the
measurement. This can be explored longer term.

X. FlashFlow measurement system: Medium term

The medium term deployment stage begins after FlashFlow has been implemented
and relays are starting to update to a version of Tor that supports it.

We plan to host a FlashFlow deployment consisting of a FF coordinator and a
single FF measurer on a single 1 Gbit/s machine. Data produced by this
deployment will be made available (semi?) publicly, including both v3bw files
and intermediate results.

Any development changes needed during this time would go through separate
proposals.

X. FlashFlow measurement system: Long term

In the long term, finishing-touch development work will be done and
experiments will be run to determine the best way to integrate FlashFlow into
the Tor ecosystem.

Any development changes needed during this time would go through separate
proposals.

X.X Authentication to Target Relay

FlashFlow measurers will maintain TLS identity certificates and use them when
connecting to target Tor relays. Dirauths will vote on which measurers are
allowed to perform measurements in the same way they currently vote on
recommended tor versions. Relays will update from stub authentication
methods to methods that actually check that the measurer used a client TLS
certificate and that it's listed in the consensus.

X.X Experiments

   [XXX todo]

X.X Other Changes/Investigations/Ideas

- How can FlashFlow data be used in a way that doesn't lead to poor load
  balancing given the following items that lead to non-uniform client
  behavior:
    - Guards that high-traffic HSs choose (for 3 months at a time)
    - Guard vs middle flag allocation issues
    - New Guard nodes (Guardfraction)
    - Exit policies other than default/all
    - Directory activity
    - Total onion service activity
    - Super long-lived circuits
- Add a cell that the target relay sends to the measurers indicating its CPU
  and memory usage, whether it has a shortage of sockets, how much bandwidth
  load it has been experiencing lately, etc. Use this information to lower a
  relays weight, never increase.
- If FlashFlow and sbws work together (as opposed to FlashFlow replacing
  sbws), consider logic for how much sbws can increase/decrease FF results
- Coordination of multiple FlashFlow deployments: scheduling of measurements,
  seeding schedule with shared random value.
- Other background/measurement traffic ratios. Dynamic? (known slow relay =>
  more allowed bg traffic?)
- Catching relays inflating their measured capacity by dropping background
  traffic.


X. Citations

[0] F. Thill. Hidden Service Tracking Detection and Bandwidth Cheating in Tor
    Anonymity Network. Master’s thesis, Univ. Luxembourg, 2014.
[1] A. Johnson, R. Jansen, N. Hopper, A. Segal, and P. Syverson. PeerFlow:
    Secure Load Balancing in Tor. Proceedings on Privacy Enhancing Technologies
    (PoPETs), 2017(2), April 2017.
